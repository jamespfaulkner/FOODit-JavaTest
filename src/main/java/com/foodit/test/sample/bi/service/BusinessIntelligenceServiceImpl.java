package com.foodit.test.sample.bi.service;

import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.inject.Inject;

import com.foodit.test.sample.bi.CategoryCountGenerator;
import com.foodit.test.sample.bi.CountGenerator;
import com.foodit.test.sample.bi.EntityCounter;
import com.foodit.test.sample.bi.OrderedMenuItemCountGenerator;
import com.foodit.test.sample.model.LineItem;
import com.foodit.test.sample.model.Menu;
import com.foodit.test.sample.model.MenuItem;
import com.foodit.test.sample.model.Order;
import com.foodit.test.sample.model.RestaurantData;
import com.foodit.test.sample.service.RestaurantDataService;
import com.google.appengine.labs.repackaged.com.google.common.collect.ImmutableList;
import com.google.appengine.repackaged.com.google.common.base.Optional;
import com.google.appengine.repackaged.com.google.common.collect.Maps;
import com.google.appengine.repackaged.com.google.common.collect.Ordering;
import com.google.appengine.repackaged.com.google.common.collect.Sets;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.gson.Gson;
import com.threewks.thundr.logger.Logger;

/**
 * Implementation of {@link BusinessIntelligenceService}.
 *
 * @author James Faulkner
 */
public class BusinessIntelligenceServiceImpl implements BusinessIntelligenceService {

    private static final Gson GSON = new Gson();

    @Inject
    private RestaurantDataService restaurantDataService;

    /**
     * {@inheritDoc}
     */
    @Override
    public String mostPopularMeals() {
        return countForEachLineItem(new OrderedMenuItemCountGenerator(), restaurantDataService.findAll());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String mostPopularMeals(String restaurantName) {
        return countForEachLineItem(new OrderedMenuItemCountGenerator(), ImmutableList.of(restaurantDataService.get(restaurantName)));
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String mostPopularCategories() {
        return countForEachLineItem(new CategoryCountGenerator(), restaurantDataService.findAll());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String mostPopularCategories(String restaurantName) {
        return countForEachLineItem(new CategoryCountGenerator(), ImmutableList.of(restaurantDataService.get(restaurantName)));
    }

    /**
     * For each {@link LineItem} for the supplied restaurants, this will create or update the {@link EntityCounter} generated by recordGenerator. The end result being a collection
     * of EntityCounters with the correct quantities. This will then be ordered (max to min) and a JSON string will be returned for them.
     *
     */
    private <T extends EntityCounter> String countForEachLineItem(final CountGenerator<T> recordGenerator, final Collection<RestaurantData> restaurantDatas) {
        Set<T> orderedMenuItemRecorders = Sets.newHashSet();      // store for all of the records of items that have been ordered.

        for (RestaurantData restaurantData : restaurantDatas) {

            Collection<Order> orders = restaurantDataService.getOrders(restaurantData);

            LoadingCache<Long, Optional<MenuItem>> cache = createMenuLoadingCache(restaurantData);

            Map<String, T> idsToCounters = Maps.newHashMap();
            for (Order order : orders) {
                for (LineItem lineItem : order.getLineItems()) {

                    Optional<MenuItem> optionalMenuItem = cache.getUnchecked(lineItem.getId());

                    if (optionalMenuItem.isPresent()) {
                        createOrAddToCounter(lineItem, optionalMenuItem.get(), restaurantData, recordGenerator, idsToCounters);
                    } else {
                        Logger.info("Unable to find the menu item with the id %d", lineItem.getId());
                    }
                }
            }
            orderedMenuItemRecorders.addAll(idsToCounters.values());
        }
        return getOrderedJsonString(orderedMenuItemRecorders);
    }

    private <T extends EntityCounter> void createOrAddToCounter(LineItem lineItem,
                                                                MenuItem menuItem,
                                                                RestaurantData restaurantData,
                                                                CountGenerator<T> recordGenerator,
                                                                Map<String, T> alreadyProcessed) {

        String uniqueId = recordGenerator.getUniqueId(lineItem, restaurantData, menuItem);
        T recorder;
        if (!alreadyProcessed.containsKey(uniqueId)) {
            recorder = recordGenerator.createRecorder(lineItem, restaurantData, menuItem);
            alreadyProcessed.put(uniqueId, recorder);
        } else {
            recorder = alreadyProcessed.get(uniqueId);
        }
        assert recorder != null;
        recorder.addQuantity(lineItem.getQuantity());
    }

    /**
     * Create a Loading Cache of type MenuId -> MenuItem for a restaurant. The MenuItem will be of type {@link Optional} since there are some ordered LineItems that don't have a
     * corresponding MenuItem
     *
     * @param restaurantData the Restaurant that the cache should be created for.
     * @return a cache that can be used to get a MenuItem from a restaurant by its ID.
     */
    private LoadingCache<Long, Optional<MenuItem>> createMenuLoadingCache(final RestaurantData restaurantData) {
        final Menu menu = restaurantDataService.getMenu(restaurantData);
        return CacheBuilder.newBuilder().build(
                new CacheLoader<Long, Optional<MenuItem>>() {
                    @Override
                    public Optional<MenuItem> load(final Long id) throws Exception {
                        for (List<MenuItem> menuItemList : menu.getMenu().values()) {
                            for (MenuItem menuItem : menuItemList) {
                                if (id.equals(menuItem.getId())) {
                                    return Optional.of(menuItem);
                                }
                            }
                        }
                        return Optional.absent();
                    }
                }
        );
    }

    /**
     * Orders the Set of {@link EntityCounter} by the {@link EntityCounter#getQuantity()} values, max to min and then creates a JSON String for them.
     *
     * @param counters the counters to order
     * @return a Json string of the counters in the correct order.
     */
    @VisibleForTesting
    <T extends EntityCounter> String getOrderedJsonString(final Set<T> counters) {
        Collection<T> orderItems = Ordering.from(
                new Comparator<T>() {
                    @Override
                    public int compare(final T o1, final T o2) {
                        return o2.getQuantity() - o1.getQuantity();
                    }
                }
        ).sortedCopy(counters);
        return GSON.toJson(orderItems);
    }
}
